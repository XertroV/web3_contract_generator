  // autogenerated - your edits will be overwritten!
  import 'dart:io';
  import 'dart:typed_data';
  import 'package:dartz/dartz.dart';
  import 'package:web3dart/web3dart.dart';
  import 'package:web3_contract_generator/helpers.dart';

  final EthereumAddress _zeroAddr =
      EthereumAddress(Uint8List(20)..fillRange(0, 20, 0));
  EthereumAddress _addrOrDefault(EthereumAddress addr) => addr ?? _zeroAddr;

  class SVIndexContract {
    final ContractAbi $abi =
        ContractAbi.fromJson(File("SVIndex.abi").readAsStringSync(), "SVIndex");
    EthereumAddress $addr;
    DeployedContract $contract;
    Web3Client $client;
    SVIndexContract(String address, Web3Client this.$client) {
      $addr = EthereumAddress.fromHex(address);
      $contract = DeployedContract($abi, $addr);
    }

    Future<String> dDeprecateCategory(FixedBytes democHash, UintType catId,
        Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dDeprecateCategory");
      var params = _f.encodeCall(<dynamic>[democHash, catId]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<UintType> getVersion({EthereumAddress from}) async {
      var _f = $contract.function("getVersion");
      var params = _f.encodeCall(<dynamic>[]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as UintType;
    }

    Future<AddressType> getBBFarm(UintType bbFarmId,
        {EthereumAddress from}) async {
      var _f = $contract.function("getBBFarm");
      var params = _f.encodeCall(<dynamic>[bbFarmId]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as AddressType;
    }

    Future<String> setOwner(
        AddressType newOwner, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("setOwner");
      var params = _f.encodeCall(<dynamic>[newOwner]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> reclaimToken(
        AddressType token, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("reclaimToken");
      var params = _f.encodeCall(<dynamic>[token]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> deprecateBBFarm(UintType bbFarmId, AddressType _bbFarm,
        Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("deprecateBBFarm");
      var params = _f.encodeCall(<dynamic>[bbFarmId, _bbFarm]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dSetCommunityBallotsEnabled(FixedBytes democHash,
        BoolType enabled, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dSetCommunityBallotsEnabled");
      var params = _f.encodeCall(<dynamic>[democHash, enabled]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dAddCategory(
        FixedBytes democHash,
        FixedBytes catName,
        BoolType hasParent,
        UintType parent,
        Wallet wallet,
        TransactionNotPayable tx) async {
      var _f = $contract.function("dAddCategory");
      var params =
          _f.encodeCall(<dynamic>[democHash, catName, hasParent, parent]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dDeployBallot(
        FixedBytes democHash,
        FixedBytes specHash,
        FixedBytes extraData,
        UintType packed,
        Wallet wallet,
        TransactionPayable tx) async {
      var _f = $contract.function("dDeployBallot");
      var params =
          _f.encodeCall(<dynamic>[democHash, specHash, extraData, packed]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> doUpgrade(
        AddressType nextSC, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("doUpgrade");
      var params = _f.encodeCall(<dynamic>[nextSC]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> setDNoEditors(
        FixedBytes democHash, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("setDNoEditors");
      var params = _f.encodeCall(<dynamic>[democHash]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> payoutAll(Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("payoutAll");
      var params = _f.encodeCall(<dynamic>[]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> addBBFarm(
        AddressType bbFarm, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("addBBFarm");
      var params = _f.encodeCall(<dynamic>[bbFarm]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<AddressType> getBackend({EthereumAddress from}) async {
      var _f = $contract.function("getBackend");
      var params = _f.encodeCall(<dynamic>[]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as AddressType;
    }

    Future<AddressType> ensOwnerPx({EthereumAddress from}) async {
      var _f = $contract.function("ensOwnerPx");
      var params = _f.encodeCall(<dynamic>[]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as AddressType;
    }

    Future<String> dDisableErc20OwnerClaim(
        FixedBytes democHash, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dDisableErc20OwnerClaim");
      var params = _f.encodeCall(<dynamic>[democHash]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<AddressType> owner({EthereumAddress from}) async {
      var _f = $contract.function("owner");
      var params = _f.encodeCall(<dynamic>[]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as AddressType;
    }

    Future<String> dDowngradeToBasic(
        FixedBytes democHash, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dDowngradeToBasic");
      var params = _f.encodeCall(<dynamic>[democHash]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dSetArbitraryData(FixedBytes democHash, DynamicBytes key,
        DynamicBytes value, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dSetArbitraryData");
      var params = _f.encodeCall(<dynamic>[democHash, key, value]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dOwnerErc20Claim(
        FixedBytes democHash, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dOwnerErc20Claim");
      var params = _f.encodeCall(<dynamic>[democHash]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> setABackend(FixedBytes toSet, AddressType newSC,
        Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("setABackend");
      var params = _f.encodeCall(<dynamic>[toSet, newSC]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<AddressType> getUpgradePointer({EthereumAddress from}) async {
      var _f = $contract.function("getUpgradePointer");
      var params = _f.encodeCall(<dynamic>[]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as AddressType;
    }

    Future<String> dDeployCommunityBallot(
        FixedBytes democHash,
        FixedBytes specHash,
        FixedBytes extraData,
        UintType packedTimes,
        Wallet wallet,
        TransactionPayable tx) async {
      var _f = $contract.function("dDeployCommunityBallot");
      var params =
          _f.encodeCall(<dynamic>[democHash, specHash, extraData, packedTimes]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<AddressType> getPayments({EthereumAddress from}) async {
      var _f = $contract.function("getPayments");
      var params = _f.encodeCall(<dynamic>[]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as AddressType;
    }

    Future<UintType> getBBFarmID(FixedBytes bbNamespace,
        {EthereumAddress from}) async {
      var _f = $contract.function("getBBFarmID");
      var params = _f.encodeCall(<dynamic>[bbNamespace]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as UintType;
    }

    Future<String> setDOwner(FixedBytes democHash, AddressType newOwner,
        Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("setDOwner");
      var params = _f.encodeCall(<dynamic>[democHash, newOwner]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dAddBallot(FixedBytes democHash, UintType ballotId,
        UintType packed, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dAddBallot");
      var params = _f.encodeCall(<dynamic>[democHash, ballotId, packed]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dUpgradeToPremium(
        FixedBytes democHash, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("dUpgradeToPremium");
      var params = _f.encodeCall(<dynamic>[democHash]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> dInit(
        AddressType defaultErc20,
        BoolType disableErc20OwnerClaim,
        Wallet wallet,
        TransactionPayable tx) async {
      var _f = $contract.function("dInit");
      var params =
          _f.encodeCall(<dynamic>[defaultErc20, disableErc20OwnerClaim]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<AddressType> getCommAuction({EthereumAddress from}) async {
      var _f = $contract.function("getCommAuction");
      var params = _f.encodeCall(<dynamic>[]);
      var result = await $client.call(
          sender: _addrOrDefault(from),
          contract: $contract,
          function: _f,
          params: params,
          atBlock: BlockNum.current());
      return result[0] as AddressType;
    }

    Future<String> setDErc20(FixedBytes democHash, AddressType newErc20,
        Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("setDErc20");
      var params = _f.encodeCall(<dynamic>[democHash, newErc20]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> setDEditor(FixedBytes democHash, AddressType editor,
        BoolType canEdit, Wallet wallet, TransactionNotPayable tx) async {
      var _f = $contract.function("setDEditor");
      var params = _f.encodeCall(<dynamic>[democHash, editor, canEdit]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }

    Future<String> $constructor(
        AddressType _b,
        AddressType _pay,
        AddressType _ensOwnerPx,
        AddressType _bbFarm0,
        AddressType _commAuction,
        Wallet wallet,
        TransactionNotPayable tx) async {
      var _f =
          $abi.functions.where((f) => f.name == "" && f.isConstructor).first;
      var params = _f
          .encodeCall(<dynamic>[_b, _pay, _ensOwnerPx, _bbFarm0, _commAuction]);
      var finalized = tx.finalize(
          data: params,
          from: await wallet.privateKey.extractAddress(),
          to: $contract.address);
      var txid = await $client.sendTransaction(wallet.privateKey, finalized,
          fetchChainIdFromNetworkId: true);
      return txid;
    }
  }
